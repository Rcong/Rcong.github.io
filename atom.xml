<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>碳14</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rcong.github.io/"/>
  <updated>2019-07-31T04:52:05.000Z</updated>
  <id>https://rcong.github.io/</id>
  
  <author>
    <name>碳14</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Three years</title>
    <link href="https://rcong.github.io/2019/07/30/2019/Three%20years/"/>
    <id>https://rcong.github.io/2019/07/30/2019/Three years/</id>
    <published>2019-07-30T14:38:10.000Z</published>
    <updated>2019-07-31T04:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>在光云的千牛事业部已经快三年了，来光云之前待的只是个两人前端的小公司，工作日常只是陪着甲方满足他们的展现需求，写写 jQuery ，改改页面，旺店交易算是我前端生涯中接触的第一个互联网产品吧，这几年看着她的产品重心从 PC 到移动，技术架构从 web 到 native ，也见识了一些商家工具的运营策略和技术辅助手段，学到了许多，开阔了眼界。所以做了一个总结，叙述这三年的工作以及内容的转变。</p><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>总结之前，先介绍一下我们的产品吧，也方便后续的展开，旺店交易 —— 阿里千牛平台的一款用户数129万，日活20万的订单管理类应用， 我们面向的用户是淘宝中小卖家群体，围绕着用户的订单生命周期内的各个需求点提供商家服务，涉及打单、改价、发货、拦截、短信等应用。</p><h2 id="交易PC业务"><a href="#交易PC业务" class="headerlink" title="交易PC业务"></a>交易PC业务</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>2016.8 - 至今</li><li>偏功能迭代、运营流量引导投放。</li></ul><p>我们的数据来源是基于千牛提供的接口去获取的，在当时那些接口都是免费的，isv们的运营策略也没有受平台方太大的约束。评分合格的 ISV 的插件每天会有许多增量用户分配进来，然后就是各 ISV 留存的手段了，当时在千牛市场内去盈利还是有许多手段的。</p><h3 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h3><p>工作的侧重点还是挖掘需求迭代新的业务功能，然后让用户去使用，根据埋点查看使用情况和引流情况，再做进一步的迭代或者推广。</p><p>刚来那半年我基本围绕了 PC 业务。PC 工程是从早些年前后不分离的项目蜕变过来的，使用了内部自研的 Tatami 框架改造成了前后端分离的 SPA 的项目。</p><p>我们的 PC 运营活动大多数的时候并不是一个新的页面，而是以弹框的形式展现在某个入口、或者某个按钮点击的时候弹出，弹框内部的一些展现逻辑还是要依据商家的一些基本信息，所以弹框逻辑是会冗余在业务模块代码中的，为了减少冗余，抽象出新老弹框的逻辑成组件。</p><p>后期项目迭代中，自研的框架已经难以满足我们的开发需求了，然后引入了 Webpack 替代了原有的打包方式，支持了 ES6 的一些特性，也可以使用 Webpack 的一些功能。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>问题: 使用内部自研的老框架，难以满足后期开发需求</li><li>解决: 引入 webpack，优化工程。</li></ul><ul><li>问题: 各种弹框类操作打包在业务文件中，业务页面加载一起加载，影响速度。</li><li>解决: <a href="https://rcong.github.io/2018/12/20/2018/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%BC%B9%E6%A1%86%E7%B1%BB%E7%BB%84%E4%BB%B6/">抽离出弹框类文件，使用 import 特性按需加载</a></li></ul><h2 id="交易H5业务"><a href="#交易H5业务" class="headerlink" title="交易H5业务"></a>交易H5业务</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li>2018.6 - 2017.3</li><li>偏功能迭代、运营流量引导投放。</li></ul><p>移动端相比 PC 端，拥有的免费和付费用户数更多，是我们核心的产品。</p><h3 id="经历-1"><a href="#经历-1" class="headerlink" title="经历"></a>经历</h3><p>移动端 Web 工程也是使用自研的 Tatami 框架改造成了前后端分离的 SPA 的项目。移动 Web 经历的时间不长，我在的半年多之后就不太维护了，转向了 native，把整个流量带过去了，这半年了除了功能迭代，也遇到过两个问题。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul><li>问题: 使用自研打包工具，打包移动端H5时需要手动拷贝比较繁琐</li><li>解决: 引入 Gulp 打包，优化原有打包流程</li></ul><ul><li>问题: 页面老是被运营商劫持，我们常被用户投诉。</li><li>解决: 项目改造 https</li></ul><h2 id="交易QAP（native）业务"><a href="#交易QAP（native）业务" class="headerlink" title="交易QAP（native）业务"></a>交易QAP（native）业务</h2><h3 id="QAP简介"><a href="#QAP简介" class="headerlink" title="QAP简介"></a><a href="https://rcong.github.io/2019/07/25/2019/QAP%E7%AE%80%E4%BB%8B/">QAP简介</a></h3><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><ul><li>2017.5 - 至今</li><li>移动 QAP 端为主，前期功能迭代，运营流量引导、续费升级为主，后期偏功能优化、UI 升级。</li></ul><p>2017年阿里千牛将整个技术方向切换到了 QAP 平台，推出使用 QAP 相关的开发方案，去解决了一些的问题。这个改变从某方面来说会将整个 ISV 重新洗牌，抓住先机的 ISV 可能会得带更多的流量引入。各个 ISV 都开始了移动 QAP 的改造，我们也抓住了这一波机会，做到了最先上架的那两家 ISV，此后的 QAP 开发中，利用在 H5 与 PC 累积的运营方式和技术辅助，我们开始了一段用户持续增长的时期……</p><p>2018年后半段，千牛市场的运营约束越来越紧，之前许多擦边球的功能都将下线；免费用户的存量规则也将变更，所有插件的存量免费用户都将重新分配，分配到评分合格的插件中。</p><h3 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h3><p>我在 QAP 开发的这一时期具体也可以分为两个阶段：</p><ul><li>一个是 QAP 开始至2019年之前，业务迅速增长，各类新功能开花，运营需求变化多。</li><li>另一个就是2019年开始，增长逐渐放缓，新功能迭代陆续变少，围绕之前一些功能做体验上的优化，运营需求也放缓了</li></ul><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p>产品迭代上，因为 QAP 前期快速上线，后续有许多待优化的地方，上线后保持着新功能的迭代，经历过一些需求，客户端SQLite数据库存储订单数据然后排序展示，连接蓝牙设备打印、数据图表展示、业务交互组件抽象等，这个过程中慢慢的重构优化一些代码、抽象出工程底层的逻辑，一些通用的业务缓存，授权逻辑，底层请求封装、组件父类、基础交互组件等。</p><p>运营这边，基于 QAP 工程去做了广告投放适配，我们业务线的广告投放做的还挺不错的，在几个兄弟部门之间得到了推广。原理是在页面挂载时去请求广告系统，根据相关的页面参数以及广告位形式，匹配是否有广告，有的话去相应的广告埋点渲染。除了广告投放，也做了一些内部嵌入业务逻辑的广告，主要还是引导或者推荐用户去订购插件，这些需求中也沉淀出一些展示类的组件。</p><h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>18年底至19年后，已经可预见性的付费用户将会下跌，一方面和整体大环境有关系，包括千牛各平台分配的用户数也逐渐在降低，平台运营规则与约束越来越紧，之前做的许多功能被迫下线，因此还损失了一大批这些功能的用户，许多以前使用的运营手段也不允许使用了，这样的背景下，用户数跌了不少。我们的需求基本切向了提升用户体验和品牌宣传。</p><p>从我们的技术角度出发，就是一些增加交互体验，挖掘小需求的点，但是基于许多模块的老代码不怎么容易植入新功能的原因，实现这些需求还是重构了一些模块，然后线上灰度，边修边上。</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul><li>问题: 项目前期快速上线，没有很好的复用模块。</li><li>解决: 沉淀基本的业务组件、交互组件，抽象各业务模块通用的底层方法。</li></ul><ul><li>问题: 难以复现线上用户的问题</li><li>解决: 获取用户授权存储在后端的数据，利用客户端能力在应用内部再开启一个应用，访问用户的环境，定位问题。</li></ul><ul><li>问题: 多数请求都是前端直接与淘宝千牛接口交互，接口限制，无法细分搜索相关功能</li><li>解决: 请求接口数据存入客户端的本地数据库，根据搜索条件拼写 sql 去本地数据库查询</li></ul><ul><li>问题: 千牛提供的图表库不能定制化，不符合业务需求。</li><li>解决: <a href="https://rcong.github.io/2018/10/02/2018/QAP%E4%B8%AD%E7%9A%84Web%20Chart%E9%9C%80%E6%B1%82/">使用H5的图表库，通过 QAP 的端的 web 组件嵌入，内外使用事件机制去通信</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt --&gt;
&lt;p&gt;在光云的千牛事业部已经快三年了，来光云之前待的只是个两人前端的小公司，工作日常只是陪着甲方满足他们的展现需求，写写 jQuery ，改改页面，旺店交易算是我前端生涯中接触的第一个互联网产品吧，这几年看着她的产品重心从 PC 到移动，技术架构
      
    
    </summary>
    
      <category term="Other" scheme="https://rcong.github.io/categories/Other/"/>
    
    
      <category term="Other" scheme="https://rcong.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>QAP简介</title>
    <link href="https://rcong.github.io/2019/07/25/2019/QAP%E7%AE%80%E4%BB%8B/"/>
    <id>https://rcong.github.io/2019/07/25/2019/QAP简介/</id>
    <published>2019-07-25T07:48:41.000Z</published>
    <updated>2019-07-30T09:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>QAP —— Qianniu Application Platform，是阿里千牛官方推出的开发者套件。底层使用了 weex 渲染，上层有 SDK 接口、Rax 库、基于 Rax 的 UI 组件库 Nuke 以及命令行工具 QAP-CLI。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>2017年以前，千牛官方使用插件的方案还是基于 webview 展现 H5 页面的形式，这样的方案下有几个问题:</p><ul><li>H5 编写的 Web App 插件使用 webview 容器加载后，会导致内存占用量飙升从而使千牛容易被系统回收。</li><li>一些运营商的劫持问题会骚扰用户和 ISV。</li><li>ISV 直接在自己的服务器端进行发布不收千牛平台方的约束和管控。</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>针对以上问题，以2017年阿里千牛将整个技术方向切换到了 QAP 平台，使用 QAP 相关的开发方案，去解决了一些的问题。</p><ul><li>经过编译的 QAP 工程代码会以 native 方式解析 JS 并运行。缩短了插件打开时间并提高运行时的效率。提供了良好的用户体验。</li><li>页面的渲染都是请求平台方的 JS Bundle 文件，然后在客户端 JS 解析与 UI 绘制，避免了运营商劫持的问题，虽然可以使用 https 解决这个问题，但是对于一些小型 ISV 来说，QAP 的方案替他们低成本的解决了问题。</li><li>发布 QAP 应用需要在 QAP 相关发布平台进行发布，千牛可以很好的约束和管控 ISV，在临近一些双十一的重大节日，可以封网发布。</li></ul><h2 id="QAP的体系"><a href="#QAP的体系" class="headerlink" title="QAP的体系"></a>QAP的体系</h2><p>上述说道 ISV 的工程会以 native 的方式解析并去运行，这样就需要两部分的代码</p><ul><li>ISV 业务代码</li><li>运行环境的 framework 代码</li></ul><p>这样就引出了一个问题，一般 ISV 的插件是一个多页面的应用，加上 framework 的底层代码，打包成 JS Bundle 就会大大增加了包的大小，从而在访问插件下发 Bundle 文件的时候影响插件的性能和用户体验。</p><p>对于这个问题，千牛官方给出的解决方案是抽离出公共的运行环境 framework 代码（ Rax、Nuke 组件以及 SDK ）放入 Main.js 里面， Main.js 是Weex的运行环境，这样 Bundle 包里面就只剩下了 ISV 的业务代码了，这样使得包的大小能够很好地控制。所以引出了下图这样的体系：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/103782/1563981630054-7e7cccc3-87a0-4715-8a2e-0d8b65171bf3.png?x-oss-process=image/resize,w_555" alt="QAP体系"></p><ul><li>顶层 JS Bundle 是 ISV 的业务代码</li><li>Rax、Nuke 组件以及 SDK 则是被抽离出内置到了 weex 的运行环境中去了，这部分负责 JS 与 natvie 之间的交互。数据绑定、事件逻辑处理等。</li></ul><p>那么在这样的体系中，整个开发流程是怎样，体验是怎么样？</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>这是根据一些淘系 weex 的 PPT 资料整理出来的图:</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/103782/1564047395539-aadd38ec-79c6-4ee4-a91d-71102d5bd29b.png?x-oss-process=image/resize,w_646" alt="流程"></p><ol><li>在这里开发者使用 weex 的 DSL —— 即 Nuke（基于 Rax 的组件库）和 Rax 来编写整个项目工程， Rax 的使用方式和 RN 类似。</li><li>相关的开发体验都会基于<a href="https://www.npmjs.com/package/qap-cli" target="_blank" rel="noopener"> QAP-CLI </a>这个脚手架，功能涉及到了初始化项目、调试、工程打包等，当开发者完成了项目，使用脚手架的打包命令<code>qap package</code>，即可以将 Rax 语法的代码 transformer 得到了纯 JS Bundle 代码。</li><li>利用 QAP 的发布平台，发布 Bundle 包到服务端/CDN。</li><li>当用户打开千牛的时候， weex runtime 就会初始化，然后去执行 JS Framework 的代码</li><li>访问 ISV 插件时，就会去服务端/CDN上请求 JS Bundle 文件</li><li>客户端 JS 解析与 UI 绘制。</li></ol><p>体验：在开发者层面的还是集中在第一点，业务层的开发，开发体验和在 Web 界面写 React 还是很接近。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过 QAP 开发，在千牛插件可以做到一次编写，两端（ iOS、Android ）运行，提高运行时的效率，提供了良好的用户体验。但与传统 Web 开发还是略有不同，文章简介了 QAP 相关，让不熟悉 QAP 的相关人员略有了解。文章有遗漏之处或者不准确的地方欢迎指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QAP —— Qianniu Application Platform，是阿里千牛官方推出的开发者套件。底层使用了 weex 渲染，上层有 SDK 接口、Rax 库、基于 Rax 的 UI 组件库 Nuke 以及命令行工具 QAP-CLI。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://rcong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="QAP" scheme="https://rcong.github.io/tags/QAP/"/>
    
  </entry>
  
  <entry>
    <title>QAP Demo 二维码</title>
    <link href="https://rcong.github.io/2019/07/17/2019/QAPDemo%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>https://rcong.github.io/2019/07/17/2019/QAPDemo二维码/</id>
    <published>2019-07-17T13:37:02.000Z</published>
    <updated>2019-07-31T02:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>下面组件的Demo二维码请用千牛扫描。</p><h2 id="WebDemo的二维码"><a href="#WebDemo的二维码" class="headerlink" title="WebDemo的二维码"></a>WebDemo的二维码</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/103782/1563543565161-a7458630-a00a-41ad-ab4c-48b576c3f44d.png" alt="WebDemo"></p><h2 id="AlertDialogDemo的二维码"><a href="#AlertDialogDemo的二维码" class="headerlink" title="AlertDialogDemo的二维码"></a>AlertDialogDemo的二维码</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/103782/1563543587536-79ee11d1-74b5-4a7c-b764-1285ce83e606.png" alt="AlertDialogDemo"></p><h2 id="PickerCardDemo的二维码"><a href="#PickerCardDemo的二维码" class="headerlink" title="PickerCardDemo的二维码"></a>PickerCardDemo的二维码</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/103782/1563543612089-d0bad5d3-afd7-4bfb-bc41-1e70f7e5c1c4.png" alt="PickerCardDemo"></p><h2 id="RateStarDemo的二维码"><a href="#RateStarDemo的二维码" class="headerlink" title="RateStarDemo的二维码"></a>RateStarDemo的二维码</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/103782/1563543651953-506d4038-f653-4aef-a210-c873663328b4.png" alt="RateStarDemo"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面组件的Demo二维码请用千牛扫描。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://rcong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="QAP" scheme="https://rcong.github.io/tags/QAP/"/>
    
  </entry>
  
  <entry>
    <title>如何理解TCP中「三次握手」和「四次挥手」</title>
    <link href="https://rcong.github.io/2019/03/15/2019/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3TCP%E4%B8%AD%E3%80%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%8D%E5%92%8C%E3%80%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E3%80%8D/"/>
    <id>https://rcong.github.io/2019/03/15/2019/如何理解TCP中「三次握手」和「四次挥手」/</id>
    <published>2019-03-15T07:48:41.000Z</published>
    <updated>2019-07-29T02:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>说起计算机网络知识中的「三次握手」和「四次挥手」，比较基础的印象就是SYN的请求与ACK、SYN的回传，FIN的请求断开等概念，描述起来只是浮于表面，所以补了一下这方面的知识，形成这篇手记。</p><p>先看一次http的请求过程：</p><ol><li>TCP建立连接</li><li>客户端发起请求</li><li>服务端响应</li><li>服务端断开TCP连接</li></ol><p><img src="https://user-images.githubusercontent.com/9363528/54278392-30273980-45cd-11e9-8ab2-72e09537cf8e.png" alt="持久连接TCP"></p><p>HTTP的下层使用了 TCP/IP的协议，所以要了解「三次握手」和「四次挥手」细节的时候，TCP相关的知识是绕不开的。</p><p><img src="https://user-images.githubusercontent.com/9363528/54278430-4634fa00-45cd-11e9-83ea-e023eeb3b392.png" alt="OSI七层模型"></p><h2 id="什么是TCP协议"><a href="#什么是TCP协议" class="headerlink" title="什么是TCP协议"></a>什么是TCP协议</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。为了提供可靠性传输，实行<strong>顺序控制</strong>和<strong>重发控制</strong>等机制。在计算机网络OSI模型中，他完成了传输层（第四层）的工作。</p><p>了解了这个协议之后，下面来看下这个TCP的内部结构，下文的理解都是建立在对于其中一些重要字段的含义之上的。</p><h2 id="TCP的头部格式"><a href="#TCP的头部格式" class="headerlink" title="TCP的头部格式"></a>TCP的头部格式</h2><p><img src="https://static001.geekbang.org/resource/image/a7/bf/a795461effcce686a43f48e094c9adbf.jpg" alt="TCP包头部"></p><h3 id="源端口号（16位）、目标端口号（16位）"><a href="#源端口号（16位）、目标端口号（16位）" class="headerlink" title="源端口号（16位）、目标端口号（16位）"></a>源端口号（16位）、目标端口号（16位）</h3><p>各占用16位字节，表示发送端端口号和接收端端口号。这端口号加上IP首部中的源端IP地址和目的端IP地址就能唯一确定一个TCP的连接。</p><h3 id="序号（Sequence-Number）-发送数据的顺序编号（32位）"><a href="#序号（Sequence-Number）-发送数据的顺序编号（32位）" class="headerlink" title="序号（Sequence Number） - 发送数据的顺序编号（32位）"></a>序号（Sequence Number） - 发送数据的顺序编号（32位）</h3><p>占用32位字节，序号用来标识从TCP发送端向TCP接受端发送的数据字节流, 它表示在这个报文段中的第一个数据字节在数据流中的位置。</p><h3 id="确认应答号（ack号）-接收数据的顺序编号（32位）"><a href="#确认应答号（ack号）-接收数据的顺序编号（32位）" class="headerlink" title="确认应答号（ack号）- 接收数据的顺序编号（32位）"></a>确认应答号（ack号）- 接收数据的顺序编号（32位）</h3><p>表示了接收方告知发送方接收方期望收到的下一个字节序号。</p><h3 id="首部长度（数据偏移量）（4位）"><a href="#首部长度（数据偏移量）（4位）" class="headerlink" title="首部长度（数据偏移量）（4位）"></a>首部长度（数据偏移量）（4位）</h3><p>占用4位字节，表示了TCP传输的数据部分应该从TCP包的哪个位开始计算。也表示了TCP包首部长度。</p><h3 id="保留（4位）"><a href="#保留（4位）" class="headerlink" title="保留（4位）"></a>保留（4位）</h3><p>占用4位字节，该字段为保留，为以后扩展使用，现在未使用。</p><h3 id="控制位（6位）"><a href="#控制位（6位）" class="headerlink" title="控制位（6位）"></a>控制位（6位）</h3><p>该字段中的每个比特分别表示以下通信控制含义。</p><ul><li>URG: 表示紧急指针字段有效</li><li>PSH: 表示通过push操作发送的数据，为1的时候接收方收到数据立马上传给上层应用协议，为0的时候不是立马上传而是先缓存起来</li><li><p>RST: 复位连接，强制断开连接，用于异常中断的情况。</p></li><li><p>ACK: 表示接收数据序号字段有效，为1时表示数据已被接收方收到，为0时没有收到。</p></li></ul><p>注：这里的ACK标志位和上文提到的确认应答号（ack号）是两个概念。</p><ul><li><p>SYN: 用于建立连接时候同步序号使用。SYN与ACK搭配使用：当请求建立连接时，SYN=1，ACK=0；连接被响应时，SYN=1，ACK=1；</p></li><li><p>FIN: 为1时表示，表示不会将有数据传送，连接将会断开。双方主机交换FIN为1的TCP包，各自对对方的FIN为1的TCP包确认应答后就可以断开。</p></li></ul><h3 id="窗口（16位）"><a href="#窗口（16位）" class="headerlink" title="窗口（16位）"></a>窗口（16位）</h3><p>占用16位字节，用于流量控制。通知从相同TCP首部的ack号所指位置开始能够接受的数据大小。TCP不允许发送超过此处所示大小的数据。</p><p>在理解了这些头部字段的含义后，再来重新审视一下「三次握手」和「四次挥手」的过程。</p><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><img src="https://static001.geekbang.org/resource/image/66/a2/666d7d20aa907d8317af3770411f5aa2.jpg" alt="三次握手"></p><ul><li>开始双方都处于关闭状态（closed），显示服务器先监听某一个端口，处于监听状态（Listen）。</li><li>第一次握手：建立连接时，客户端主动发送报文段（SYN=1，seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；</li><li><p>第二次握手：服务器收到SYN报文段，必须确认客户的报文段。此时会响应一个报文段，这个报文段的SYN=1，控制位ACK=1，ack号=x+1（对应第一次握手中的seq数+1），seq=y，然后服务器进入SYN_RECV状态。</p></li><li><p>第三次握手：客户端收到服务器的SYN+ACK包后，需要响应<strong>服务器的应答应答报文段</strong>一个报文段，这个报文段的控制位ACK=1，ack号=y+1（对应第二次握手中的seq数+1），seq=x+1（对应第二次我手中的ack号），然后客户端进入建立连接（ESTABLISHED）的状态，服务端接受到这个报文段后也进入建立连接（ESTABLISHED）的状态。</p></li></ul><p>这三个报文段完成连接的建立过程就是三次握手。</p><p>看完了建立连接，再来看一下断开连接。</p><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>当建立起TCP连接之后，客户端和服务器端传输完数据，两端就要断开TCP连接，于是就有了四次挥手。</p><p><img src="https://static001.geekbang.org/resource/image/1f/11/1f6a5e17b34f00d28722428b7b8ccb11.jpg" alt="四次挥手"></p><ul><li>第一次挥手：关闭方A发送一个报文段（seq=p，FIN=1），然后进入FIN_WAIT_1状态，发送FIN标志位，表示关闭方A将不会再有数据传送，连接将会断开。</li><li>第二次挥手：接收方B收到的关闭方A的FIN报文段，会响应一个方的报文段，该报文段的控制位ACK=1，ack号为p+1（对应第一次回收中的seq数p加1），然后进入CLOSED_WAIT状态。这个过程表示了接收方收到了关闭方的关闭请求。</li><li>第三次挥手：接收方B发出FIN报文段（FIN=1，seq=q，ack=p+1，控制位ACK=1），然后进入LAST_ACK状态。</li><li>第四次挥手：关闭方A收到接收方B的FIN报文段，会响应一个报文段该报文段的控制位ACK=1，ack号为q+1（对应第三次回收中的seq数q加1），然后关闭方A就进入TIME_WAIT状态。接收方B收到响报文段之后，就关闭连接（CLOSED），关闭方A等待2MSL后没有收到回复，则关闭方A也关闭连接进入CLOSED状态。</li></ul><blockquote><p>注:MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>四次挥手的过程可以形象地理解为一问一答，双方都经过了这个过程就可以结束这个连接了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>「三次握手」和「四次挥手」的基本过程就结束了，但是TCP协议中还有许多可以去深挖的点，有兴趣的话可以读一下《TCP-IP详解》、《图解TCP IP》，这两本书也是本篇手记的参考资料。有机会读完再和大家分享一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《TCP/IP详解》</li><li>《图解TCP/IP》</li><li><a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间-趣谈网络协议</a></li><li><a href="https://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">TCP的三次握手(建立连接）和四次挥手(关闭连接）</a></li><li><a href="https://blog.csdn.net/oney139/article/details/8103223" target="_blank" rel="noopener">TCP三次握手详解及释放连接过程</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解TCP协议的三次握手和四次分手</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起计算机网络知识中的「三次握手」和「四次挥手」，比较基础的印象就是SYN的请求与ACK、SYN的回传，FIN的请求断开等概念，描述起来只是浮于表面，所以补了一下这方面的知识，形成这篇手记。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://rcong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="TCP" scheme="https://rcong.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>浅析DNS协议</title>
    <link href="https://rcong.github.io/2019/02/17/2019/%E6%B5%85%E6%9E%90DNS%E5%8D%8F%E8%AE%AE/"/>
    <id>https://rcong.github.io/2019/02/17/2019/浅析DNS协议/</id>
    <published>2019-02-17T12:48:02.000Z</published>
    <updated>2019-07-29T02:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>在网络中，网站的IP地址很难让人去记住，一般都是使用域名去访问，因此就有了DNS服务器，根据IP查询域名的地址簿。</p><p>每台计算器上都有相应的DNS客户端，也称作DNS解析器。通过DNS查询IP地址的操作称为域名解析，DNS解析器实际上是一段代码，包含在了操作系统的Socket库中，Socket是C语言实现的调用网络功能的库。</p><h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><p>浏览器调用解析器时，切换到了解析器的上下文执行环境切，也就是Socket中的一段代码 <code>gethostbyname</code> ,这段代码会生成发送给DNS服务器的查询消息，与浏览器生成http请求的过程类似，然后将消息发送给DNS服务器。发送这个过程并不是解析器来执行的，而是委托给了操作系统内部的协议栈去做处理，协议栈通过网卡将消息发送给DNS服务器。</p><p><img src="https://user-images.githubusercontent.com/9363528/54486364-5d703200-48c2-11e9-9731-669e4b63cfa9.jpg" alt="调用解析器时计算机内部工作流程"></p><blockquote><p>与DNS服务器交互时，他的IP地址不需要查询，而是在操作系统中去设置好的，比如Mac的话，就在 <code>系统偏好设置 -&gt; 网络 -&gt; 高级 -&gt; DNS</code>中去设置。</p></blockquote><h2 id="DNS的接受和响应消息"><a href="#DNS的接受和响应消息" class="headerlink" title="DNS的接受和响应消息"></a>DNS的接受和响应消息</h2><p>来自客户端的查询消息包含3中信息</p><ul><li>域名<blockquote><p>服务器、邮件服务器的名称</p></blockquote></li><li>Class<blockquote><p>用来识别网络信息，值为IN，代表了Internet。</p></blockquote></li><li>记录类型<blockquote><p>表示域名对应何种类型的记录。A: 域名对应IP地址；MX: 域名对应邮件服务器。</p></blockquote></li></ul><p>DNS服务器中保存了这三种信息对应的数据，类似这样子:</p><table><thead><tr><th>域名</th><th>Class</th><th>记录类型</th><th>响应数据</th></tr></thead><tbody><tr><td>wdst2.superboss.cc</td><td>IN</td><td>A</td><td>121.43.69.90</td></tr><tr><td>imap.exmail.qq.com</td><td>IN</td><td>MX</td><td>14.17.57.217</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>根据查询请求返回符合的响应，比如查询wdst2.superboss.cc时，发送DNS服务器的查询信息就包含以下内容:</p><ul><li>域名:wdst2.superboss.cc</li><li>Class:IN</li><li>记录类型:A</li></ul><p>然后DNS服务器根据存储查找对应返回IP给客户端。  </p><h2 id="域名层次结构"><a href="#域名层次结构" class="headerlink" title="域名层次结构"></a>域名层次结构</h2><p>每个人上网，都需要访问DNS，上网的人分布在全世界各地，如果大家都去同一个地方访问某一台服务器，时延将会非常大。因而，DNS 服务器，一定是设置成<strong>高可用、高并发和分布式</strong>的。</p><p>所以DNS的层次是树状结构:</p><p><img src="https://user-images.githubusercontent.com/9363528/54486374-6c56e480-48c2-11e9-8669-b952a617b98b.jpg" alt="DNS树状结构"></p><blockquote><p>分配给根DNS服务器的IP全世界仅有13个，不用于域名解析，只用于指引DNS请求。</p></blockquote><h2 id="寻找相应的DNS并获取IP"><a href="#寻找相应的DNS并获取IP" class="headerlink" title="寻找相应的DNS并获取IP"></a>寻找相应的DNS并获取IP</h2><ol><li><p>客户端发送一个DNS请求，比如说访问<a href="http://www.superboss.cc/" target="_blank" rel="noopener">http://www.superboss.cc/</a>，这个请求会发送到最近的DNS服务器。</p></li><li><p>最近的DNS服务器收到来自客户端的请求，会去缓存中找，如果找到了<a href="http://www.superboss.cc，直接返回。没有的话，该DNS会去访问根DNS服务器。" target="_blank" rel="noopener">www.superboss.cc，直接返回。没有的话，该DNS会去访问根DNS服务器。</a></p></li><li><p>根DNS服务器中根据域名结构判断，属于cc域，返回cc域中的DNS服务器的IP地址。</p></li><li><p>接着最近DNS服务器又会向cc域的DNS发送请求，cc域判断他的缓存中有么有<a href="http://www.superboss.cc的ip，没有的话返回下面superboss.cc的DNS服务器的IP。" target="_blank" rel="noopener">www.superboss.cc的ip，没有的话返回下面superboss.cc的DNS服务器的IP。</a></p></li></ol><p>以此类推，直到找到拥有目标域名的IP的DNS服务器，然后返回IP。</p><p>总结一下就是下图这么一个流程</p><p><img src="https://static001.geekbang.org/resource/image/ff/f2/ff7e8f824ebd1f7e16ef5d70cd79bdf2.jpg" alt="image"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>以上这个过程是一次递归DNS服务器，这个过程除了查出映射的IP地址，还起到了负载均衡的作用。</p><h3 id="内部负载均衡"><a href="#内部负载均衡" class="headerlink" title="内部负载均衡"></a>内部负载均衡</h3><p>例如，一个应用要访问数据库，在这个应用里面应该配置这个数据库的 IP 地址，还是应该配置这个数据库的域名呢？显然应该配置域名，因为一旦这个数据库，因为某种原因，换到了另外一台机器上，而如果有多个应用都配置了这台数据库的话，一换 IP 地址，就需要将这些应用全部修改一遍。但是如果配置了域名，则只要在 DNS 服务器里，将域名映射为新的 IP 地址，这个工作就完成了，大大简化了运维。</p><p>在这个基础上，我们可以再进一步。例如，A应用要访问B应用，如果配置另外一个应用的 IP 地址，那么这个访问就是一对一的。但是当B应用撑不住的时候，我们其实可以部署多个。但是，A应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，返回不同的IP，就可以实现负载均衡了。</p><h3 id="全局负载均衡"><a href="#全局负载均衡" class="headerlink" title="全局负载均衡"></a>全局负载均衡</h3><p>为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用。</p><p>另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://segmentfault.com/q/1010000007713951" target="_blank" rel="noopener">浏览器的、本地的、hosts的各种DNS缓存里查找后，最后访问的DNS服务器是哪个服务器？</a></p><p><a href="https://time.geekbang.org/column/article/9895" target="_blank" rel="noopener">DNS协议：网络世界的地址簿</a></p><p>《网络是怎么连接的》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络中，网站的IP地址很难让人去记住，一般都是使用域名去访问，因此就有了DNS服务器，根据IP查询域名的地址簿。&lt;/p&gt;
&lt;p&gt;每台计算器上都有相应的DNS客户端，也称作DNS解析器。通过DNS查询IP地址的操作称为域名解析，DNS解析器实际上是一段代码，包含在了操作系统的Socket库中，Socket是C语言实现的调用网络功能的库。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://rcong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DNS" scheme="https://rcong.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>按需加载弹框类组件</title>
    <link href="https://rcong.github.io/2018/12/20/2018/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%BC%B9%E6%A1%86%E7%B1%BB%E7%BB%84%E4%BB%B6/"/>
    <id>https://rcong.github.io/2018/12/20/2018/按需加载弹框类组件/</id>
    <published>2018-12-20T05:11:52.000Z</published>
    <updated>2019-07-29T15:20:34.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>部门有个老项目，使用的是原生js自研框架，是那种spa架构的产品，比较多的一个场景是列表或者表单，点击某个按钮有一些弹框的操作。目前的打包处理方式，这类弹框业务组件和一些基础的通用函数放置在一块打包成chunk，再根据一级路由划分打包成不同业务模块的js文件。所以打开页面时，会去加载某个路由js文件以及chunk文件。</p><p>chunk里面包含了一大堆弹框业务组件导致文件变大，影响首屏加载的速度，怎么去优化这个文件大小比较合适？</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul><li>方法一：从代码角度出发，重构一下业务组件，抽离这些弹框操作的共有部分，节约一大波重复代码。</li><li>方法二：改变业务组件的引入方式，根据各路由模块拆分业务组件，然后再按需加载文件。</li></ul><p>方法一比较花时间，并且需要对业务特别熟悉。团队人员变更较多，并且业务紧急的情况下不太可取。方法二按需加载时花点时间去加载js文件，但交互上感知轻微，并且相比方案一，方案二更可执行。所以采取方案二，那么怎么做到按需加载呢？</p><h2 id="使用import（）按需加载弹框类组件"><a href="#使用import（）按需加载弹框类组件" class="headerlink" title="使用import（）按需加载弹框类组件"></a>使用import（）按需加载弹框类组件</h2><p>配合webpack使用符合<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">ECMAScript提案</a>的<strong>import()语法</strong>来实现动态导入。</p><p>之前一般都是业务组件和基础函数一类打包成chunk文件，首屏加载时引入，相应的引入方式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; initXXXModal &#125; from &apos;COMMON/xxxModals&apos;</span><br><span class="line"></span><br><span class="line">//当监听中调用时</span><br><span class="line">button.addEventListener(&apos;click&apos;, event =&gt; &#123;</span><br><span class="line">    initXXXModal(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这在文件比较小的时候还行，但项目迭代了，文件大了，就会影响加载速度，使用import()改进后如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//当监听中调用时</span><br><span class="line">button.addEventListener(&apos;click&apos;, event =&gt; &#123;</span><br><span class="line">    import(/* webpackChunkName: &quot;xxxModals&quot; */ &apos;COMMON/xxxModals/index).then((&#123; initXXXModal &#125;) =&gt; &#123;</span><br><span class="line">        initXXXModal(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>打包后会形成一个xxxModals.js文件，只有点击button时才会去加载。</p><p>xxxModals只涉及到某个人编写的某几处弹框组件，那么整个项目中各路由下的各自的组件如果都以这样的方式打包的话，那么最后会形成多个组件的js文件。</p><p>目前以一级路由来划分所有业务组件，某个路由下的组件统一一个chunkFile，在使用时再加载这个文件。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这只是一次简单的利用webpack和import()特性优化的过程，如果不使用webpack，怎么去优化呢？</p><ul><li>可以使用动态创建script来加载文件，点击时去加载弹框类的js文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var _asyncScript = function(src, cb) &#123;</span><br><span class="line">    var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">    var s = document.createElement(&apos;script&apos;);</span><br><span class="line">    s.src = src;</span><br><span class="line">    s.async = &apos;async&apos;;</span><br><span class="line">    s.onload = function() &#123;</span><br><span class="line">        cb &amp;&amp; cb();</span><br><span class="line">    &#125;;</span><br><span class="line">    body.appendChild(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;部门有个老项目，使用的是原生js自研框架，是那种spa架构的产品，比较多的一个场景是列表或者表单，点击某个按钮有一些弹框的操作。目前的打包处理方式，这类弹框业务组件和一些基础的通用函数放置在一块打包成chunk，再根据一级路由划分打包成不同业务模块的js文件。所以打开页面时，会去加载某个路由js文件以及chunk文件。&lt;/p&gt;
&lt;p&gt;chunk里面包含了一大堆弹框业务组件导致文件变大，影响首屏加载的速度，怎么去优化这个文件大小比较合适？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://rcong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="https://rcong.github.io/tags/js/"/>
    
      <category term="webpack" scheme="https://rcong.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>QAP中的Web Chart需求</title>
    <link href="https://rcong.github.io/2018/10/02/2018/QAP%E4%B8%AD%E7%9A%84Web%20Chart%E9%9C%80%E6%B1%82/"/>
    <id>https://rcong.github.io/2018/10/02/2018/QAP中的Web Chart需求/</id>
    <published>2018-10-02T11:48:41.000Z</published>
    <updated>2019-07-29T02:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>QAP的Chart库是基于weex + rax, 包含了线图、柱状图、饼图、雷达图等，由客户端插件实现，性能好，开发友好，直接引用就行。</p><ul><li>QAP原生的Chart</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/103782/1563428248981-ebf27849-d181-47b1-a1cf-71337504f383.png?x-oss-process=image/resize,w_579" alt="Qap Chart"></p><p>但是对于各插件商自己的业务需求，QAP的Chart库很难去满足不同的展现逻辑和需求。</p><ul><li>使用H5达到效果的Chart</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/103782/1563425928516-2ecec587-7828-4570-a9b1-ad34ba93ed81.jpeg?x-oss-process=image/resize,w_450" alt="H5 Chart"></p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>H5中的Chart库相对于QAP的图表库拥有更丰富的自定义设置，可以满足日常业务方所需要的展示逻辑和需求，但是H5的Chart库怎么在以Weex渲染的QAP平台中去展现的?</p><ul><li>在native端使用weex提供的Web网页容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createElement, Component, render&#125; from &apos;rax&apos;; // eslint-disable-line no-unused-vars</span><br><span class="line">import &#123; Web, Page, Modal, Button, View &#125; from &apos;nuke&apos;;</span><br><span class="line">import QAP from &apos;QAP-SDK&apos;;</span><br><span class="line"></span><br><span class="line">const styles = &#123;</span><br><span class="line">    content : &#123;</span><br><span class="line">        height:&apos;500rem&apos;,</span><br><span class="line">        margin:&apos;30rem&apos;,</span><br><span class="line">        padding:&apos;10rem&apos;,</span><br><span class="line">        backgroundColor:&apos;#ffffff&apos;,</span><br><span class="line">        justifyContent:&apos;center&apos;,</span><br><span class="line">        alignItems:&apos;center&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    btns:&#123;</span><br><span class="line">        margin:&apos;30rem&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WebDemo extends Component &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.eventsBind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventsBind()&#123;</span><br><span class="line">        QAP.on(&apos;App.WebChart.chartDemoLoaded&apos;, () =&gt; &#123;</span><br><span class="line">            Modal.toast(&apos;H5页面Loaded&apos;);</span><br><span class="line">            this.getRandomData()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRandomData()&#123;</span><br><span class="line">        let date = [&apos;09.06&apos;, &apos;09.07&apos;, &apos;09.08&apos;, &apos;09.09&apos;, &apos;09.10&apos;, &apos;09.11&apos;, &apos;09.12&apos;],</span><br><span class="line">            data = [Math.random() * 100, Math.random() * 100, Math.random() * 100, Math.random() * 100, Math.random() * 100, Math.random() * 100, Math.random() * 100];</span><br><span class="line"></span><br><span class="line">        QAP.emit(&apos;App.WebChart.chartDemo&apos;, &#123;date: date, data: data, util: &apos;QAP与H5图表通信随机数据&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Page title=&quot;Web&quot;&gt;</span><br><span class="line">                &lt;Page.Intro main=&quot;使用 web 组件载入图表页面,H5托管七牛云&quot;&gt;&lt;/Page.Intro&gt;</span><br><span class="line">                &lt;Web style=&#123;[styles.content]&#125; src=&quot;http://puqqf48gp.bkt.clouddn.com/chartDemo.html&quot;&gt;&lt;/Web&gt;</span><br><span class="line">                &lt;View style=&#123;styles.btns&#125;&gt;</span><br><span class="line">                    &lt;Button onPress=&#123;this.getRandomData&#125; block=&quot;true&quot; type=&quot;primary&quot;&gt;随机数据&lt;/Button&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            &lt;/Page&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(&lt;WebDemo/&gt;);</span><br></pre></td></tr></table></figure><ul><li>H5页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;图表展示&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://g.alicdn.com/x-bridge/qap-sdk/1.0.10/qn.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://g.alicdn.com/sj/lib/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://code.highcharts.com.cn/highcharts/highcharts.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;chartContainer&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function() &#123;</span><br><span class="line">        QN.emit(&apos;App.WebChart.chartDemoLoaded&apos;, true);</span><br><span class="line"></span><br><span class="line">        QN.on(&apos;App.WebChart.chartDemo&apos;, function(chartParam) &#123;</span><br><span class="line">            //图表展示逻辑</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="整体的逻辑"><a href="#整体的逻辑" class="headerlink" title="整体的逻辑"></a>整体的逻辑</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/103782/1563465445206-12edc4de-0029-4787-a217-9e585d9ba462.jpeg?x-oss-process=image/resize,w_746" alt="整体的逻辑"></p><p>总的来说,通过QAP提供的事件机制起到Web页与QAP页面的通信。Web页面的展现逻辑相对于Weex渲染的页面和组件可以做到更丰富。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;QAP的Chart库是基于weex + rax, 包含了线图、柱状图、饼图、雷达图等，由客户端插件实现，性能好，开发友好，直接引用就行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QAP原生的Chart&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/103782/1563428248981-ebf27849-d181-47b1-a1cf-71337504f383.png?x-oss-process=image/resize,w_579&quot; alt=&quot;Qap Chart&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是对于各插件商自己的业务需求，QAP的Chart库很难去满足不同的展现逻辑和需求。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://rcong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="QAP" scheme="https://rcong.github.io/tags/QAP/"/>
    
  </entry>
  
  <entry>
    <title>高性能JavaScript学习手记-执行与加载</title>
    <link href="https://rcong.github.io/2016/12/02/2016/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0-%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%8A%A0%E8%BD%BD/"/>
    <id>https://rcong.github.io/2016/12/02/2016/高性能JavaScript学习手记-执行与加载/</id>
    <published>2016-12-02T07:48:41.000Z</published>
    <updated>2019-07-29T02:30:17.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>浏览器在处理HTML页面渲染和JavaScript脚本执行的时候是单一进程的,所以在当浏览器在渲染HTML遇到了<code>&lt;script&gt;</code>标签会先去执行标签内的代码(如果是使用src属性加载的外链文件,则先下载再执行),在这个过程中,页面渲染和交互都会被阻塞。</p><p>…虽然会有阻塞,但还是有几招可以减少JavaScript对性能的影响的。</p><hr><h2 id="1-script标签的位置"><a href="#1-script标签的位置" class="headerlink" title="1.script标签的位置"></a><strong>1.script标签的位置</strong></h2><p>当<code>&lt;script&gt;</code>出现在<code>&lt;head&gt;</code>中的时候,比如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js1.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js2.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js3.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br></pre></td></tr></table></figure><p>这种加载多个js文件的时候,浏览器就会因先下载执行js代码而阻塞页面渲染从而出现白屏页面(浏览器解析到<code>&lt;body&gt;</code>标签之前,不会渲染页面任何内容),没法预览也没法交互,很差劲的用户体验。</p><p><strong>注意:</strong></p><ul><li><strong>现代浏览器支持资源并行下载,只限于<code>&lt;script&gt;</code>下载外部资源的时候不会阻塞其他<code>&lt;script&gt;</code>标签,但会阻塞其他资源的下载。</strong></li><li><strong>下载JavaScript资源是异步的,但是执行JavaScript代码的时候仍是同步的,同样会造成阻塞。</strong></li></ul><p>所以把<code>&lt;script&gt;</code>后置到<code>&lt;body&gt;</code>标签的底部,保证执行脚本之前已完成页面渲染,是一种比较常用的JavaScript优化手段。</p><hr><h2 id="2-合并多个script标签"><a href="#2-合并多个script标签" class="headerlink" title="2.合并多个script标签"></a><strong>2.合并多个script标签</strong></h2><p>浏览器解析HTML时遇到<code>&lt;script&gt;</code>都会因为执行脚本而有一定的延迟,对于有src属性的外链则<code>&lt;script&gt;</code>更加,多HTTP请求则会带来更多的性能开销,尽量减少这种延迟,也是一种优化手段,可以合并多个js文件来减少HTTP请求的次数,减少三次握手的次数和多余的HTTP头传输,降低响应时间提高用户体验。网上有许多合并js的方案以及工具,在这不叙述了。</p><hr><h2 id="3-使用无阻塞下载JavaScript的方法"><a href="#3-使用无阻塞下载JavaScript的方法" class="headerlink" title="3.使用无阻塞下载JavaScript的方法"></a><strong>3.使用无阻塞下载JavaScript的方法</strong></h2><ol><li>使用script标签的defer和async属性</li><li>使用动态创建的script标签来下载执行JavaScript代码</li><li>使用XHR对象下载JavaScript代码并注入页面<h3 id="3-1-使用script标签的defer和async属性"><a href="#3-1-使用script标签的defer和async属性" class="headerlink" title="3.1.使用script标签的defer和async属性"></a><strong>3.1.使用script标签的defer和async属性</strong></h3></li></ol><p>async和defer属性都是用于异步加载js文件,期间不会才生阻塞浏览器其他进程,区别在于async是加载完之后自动执行,而defer需要等到页面加载之后再执行,需要注意的一点是这两个属性必须在有src属性的<code>&lt;script&gt;</code>标签中(外链脚本)才有效。下面是demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;defer example&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"defer.js"</span> defer&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        alert(<span class="string">"script"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        window.onload= function()&#123;</span></span><br><span class="line"><span class="regexp">            alert("load");</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;defer demo&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="demo"&gt;defer demo&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;defer demo&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="demo"&gt;defer demo&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;defer demo&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="demo"&gt;defer demo&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;defer demo&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="demo"&gt;defer demo&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;defer demo&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="demo"&gt;defer demo&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;defer demo&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="demo"&gt;defer demo&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//defer.js的文件下只有alert("defer");一行代码</span></span><br></pre></td></tr></table></figure><p>async的例子也是相同的页面结构,这里就不摆例子了,可以戳下面的链接。<br><a href="http://book.jirengu.com/Rcong/my-practical-code/defer-async-demo/defer.html" target="_blank" rel="noopener">defer example的链接戳这里!</a><br><a href="http://book.jirengu.com/Rcong/my-practical-code/defer-async-demo/async.html" target="_blank" rel="noopener">async example的链接戳这里!</a><br>虽然页面结构一样,但不一样的是</p><ul><li>打开defer.html依次看到是: 弹出”script”的alert框=&gt;页面渲染出文字=&gt;弹出”defer”的alert框=&gt;弹出”load”的alert框</li><li>打开async.html依次看到是: 弹出”script”的alert框=&gt;弹出”async”的alert框=&gt;页面渲染出文字=&gt;弹出”load”的alert框<h3 id="3-2-使用动态创建的script标签来下载执行JavaScript代码"><a href="#3-2-使用动态创建的script标签来下载执行JavaScript代码" class="headerlink" title="3.2.使用动态创建的script标签来下载执行JavaScript代码"></a><strong>3.2.使用动态创建的script标签来下载执行JavaScript代码</strong></h3></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"file.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure><p>file.js在script元素添加到页面时就启动下载,使用这种方式的优势在于<strong>file.js的下载和执行不会阻塞页面其他进程。</strong><br>下面是普通方式和动态添加脚本方式的两个demo,file.js中仅仅是一个10000次的for循环和之后弹出一个alert框的几句代码。<br><a href="http://book.jirengu.com/Rcong/my-practical-code/dynamic-script-element/dynamic.html" target="_blank" rel="noopener">动态添加script元素的Demo链接戳这里!</a><br><a href="http://book.jirengu.com/Rcong/my-practical-code/dynamic-script-element/normal.html" target="_blank" rel="noopener">普通的引入script脚本Demo链接戳这里!</a><br>从demo上可以明显的看出动态加载方式可以在alert框弹出之前先看到页面上的文字,但是普通的方式只有在alert框弹出之后才可以看到页面上的文字。</p><p>我们可以封装一个跨浏览器的读取script脚本并动态创建script标签的函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    <span class="comment">//检测客户端类型</span></span><br><span class="line">    <span class="keyword">if</span>(script.readyState)&#123;<span class="comment">//IE</span></span><br><span class="line">        script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(script.readyState===<span class="string">"loaded"</span>||script.readyState===<span class="string">"complete"</span>)&#123;</span><br><span class="line">                script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//其他浏览器</span></span><br><span class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这类动态加载脚本的方法兼容性好,也比较简单,是一种常用的无阻塞解决方案。</strong></p><h3 id="3-3-使用XHR对象下载JavaScript代码并注入页面"><a href="#3-3-使用XHR对象下载JavaScript代码并注入页面" class="headerlink" title="3.3.使用XHR对象下载JavaScript代码并注入页面"></a><strong>3.3.使用XHR对象下载JavaScript代码并注入页面</strong></h3><p>另一种无阻塞加载脚本的方式是使用XMLHttpRequest(XHR)对象获取脚本并注入页面中。<br><strong>这种技术会先创建一个XHR对象,然后用他下载JavaScript文件,最后通过常见动态<code>&lt;script&gt;</code>元素将代码注入页面中。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"file.js"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">            script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">            script.text = xhr.responseText;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://book.jirengu.com/Rcong/my-practical-code/XMLHttpRequest-script-injection/XMLHttpRequest.html" target="_blank" rel="noopener">Demo在这儿!快让我到碗里去!</a><br>以上代码发送GET请求file.js文件,onReadyStateChange检测readyState是否为4(4表示请求完成)和HTTP状态吗是否有效(200表示有效响应,304表示读取缓存)。判断响应有效之后,就动态创建一个<code>&lt;script&gt;</code>标签,内容就是服务器接收到的responseText。</p><p>这种方法的优点以及缺点:</p><ul><li>优点:下载JavaScript代码可以不立即执行,且兼容性好适合所有主流浏览器。</li><li>缺点:JavaScript文件必须与所请求页面处于同一个域,这种情况下JavaScript文件不能从CDN下载,不适合大型的Web应用。</li></ul><hr><h2 id="4-一种推荐的无阻塞方案"><a href="#4-一种推荐的无阻塞方案" class="headerlink" title="4.一种推荐的无阻塞方案"></a><strong>4.一种推荐的无阻塞方案</strong></h2><p>如果页面有大量的JavaScript代码需要添加,可以先在页面中去外链之前我们封装好的动态读取script脚本的函数loadScript,然后再使用它去加载其他所需脚本,例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"loader.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    loadScript(<span class="string">"file.js"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这样只需在第一个<code>&lt;script&gt;</code>下载比较精简的loader.js文件时对页面有些许影响,之后的<code>&lt;script&gt;</code>并不会有太多影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器在处理HTML页面渲染和JavaScript脚本执行的时候是单一进程的,所以在当浏览器在渲染HTML遇到了&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签会先去执行标签内的代码(如果是使用src属性加载的外链文件,则先下载再执行),在这个过程中,页面渲染和交互都会被阻塞。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://rcong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="https://rcong.github.io/tags/js/"/>
    
  </entry>
  
</feed>
